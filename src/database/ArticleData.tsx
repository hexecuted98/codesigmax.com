import type { BlogPost } from "../Interface/BlogPost";

export const blogPosts: BlogPost[] = [
    {
        id: "post_1",
        title: "Fundamental React JS untuk Pemula",
        excerpt: "Pelajari langkah langkah dan cara cara fundamental tentang react js",
        content: "--- \n\n## Pendahuluan: Mengapa React JS? \n\n**React JS** adalah _library_ JavaScript yang populer untuk membangun antarmuka pengguna (UI). Dikembangkan oleh Facebook, React memungkinkan Anda membuat aplikasi _web_ yang _interaktif_ dan _efisien_ dengan pendekatan berbasis komponen. Dengan React, Anda dapat memecah UI menjadi bagian-bagian kecil yang dapat digunakan kembali, membuat pengembangan lebih teratur dan _scalable_. \n\n--- \n\n## Konsep Dasar React JS \n\nUntuk memahami React, ada beberapa konsep fundamental yang harus Anda kuasai. \n\n### 1. Komponen (Components) \n\nKomponen adalah _building block_ utama di React. Setiap bagian dari UI Anda bisa dianggap sebagai komponen. Ada dua jenis komponen utama: \n\n* **Komponen Fungsional (Functional Components):** Ini adalah fungsi JavaScript sederhana yang mengembalikan elemen React. Sejak diperkenalkannya _Hooks_, komponen fungsional menjadi pilihan utama karena kesederhanaan dan kemampuannya untuk mengelola _state_ dan _lifecycle_. \n\n    ```jsx \n    import React from 'react'; \n\n    function WelcomeMessage(props) { \n        return <h1>Halo, {props.name}!</h1>; \n    } \n\n    export default WelcomeMessage; \n    ``` \n\n* **Komponen Kelas (Class Components):** Ini adalah kelas JavaScript yang memperluas `React.Component`. Sebelum _Hooks_, ini adalah cara utama untuk membuat komponen dengan _state_ dan _lifecycle methods_. Meskipun masih digunakan dalam banyak kode lama, komponen fungsional lebih disukai untuk proyek baru. \n\n    ```jsx \n    import React from 'react'; \n\n    class Counter extends React.Component { \n        constructor(props) { \n            super(props); \n            this.state = { count: 0 }; \n        } \n\n        render() { \n            return ( \n                <div> \n                    <p>Hitungan: {this.state.count}</p> \n                    <button onClick={() => this.setState({ count: this.state.count + 1 })}> \n                        Tambah \n                    </button> \n                </div> \n            ); \n        } \n    } \n\n    export default Counter; \n    ``` \n\n### 2. JSX (JavaScript XML) \n\n**JSX** adalah ekstensi sintaks JavaScript yang memungkinkan Anda menulis kode seperti HTML di dalam JavaScript. Ini bukan string atau HTML, melainkan sintaks yang akan di-_compile_ oleh Babel menjadi panggilan `React.createElement()` biasa. \n\n```jsx \nconst element = <h1>Halo, Dunia!</h1>; \n``` \n\nManfaat JSX meliputi: \n\n* **Lebih Deklaratif:** UI Anda menjadi lebih intuitif dan mudah dibaca. \n* **Kompilasi Cepat:** Dioptimalkan untuk performa. \n* **Kesalahan Lebih Mudah Ditangkap:** Kesalahan sintaks akan dideteksi pada waktu kompilasi. \n\n### 3. Props (Properties) \n\n**Props** adalah cara untuk meneruskan data dari komponen induk ke komponen anak. _Props_ bersifat _read-only_, artinya komponen anak tidak dapat mengubah _props_ yang diterimanya. Ini membantu menjaga _data flow_ satu arah (`one-way data flow`), membuat aplikasi lebih mudah diprediksi. \n\n```jsx \n// Komponen Induk \nfunction App() { \n    return <WelcomeMessage name=\"Adjidev\" />; \n} \n\n// Komponen Anak (lihat WelcomeMessage di bagian Komponen Fungsional) \n``` \n\n### 4. State \n\n**State** adalah objek JavaScript yang digunakan untuk menyimpan data yang dapat berubah seiring waktu dalam sebuah komponen. Ketika _state_ berubah, komponen akan di-_render_ ulang (_re-render_) untuk mencerminkan perubahan tersebut. Hanya komponen yang memiliki _state_ yang dapat mengubah _state_ mereka sendiri. \n\nPada komponen fungsional, Anda mengelola _state_ menggunakan _Hook_ `useState`. \n\n```jsx \nimport React, { useState } from 'react'; \n\nfunction Counter() { \n    const [count, setCount] = useState(0); // [nilai_state, fungsi_pengubah_state] = useState(nilai_awal) \n\n    return ( \n        <div> \n            <p>Hitungan: {count}</p> \n            <button onClick={() => setCount(count + 1)}> \n                Tambah \n            </button> \n        </div> \n    ); \n} \n\nexport default Counter; \n``` \n\n### 5. Lifecycle Methods (untuk Komponen Kelas) dan Hooks (untuk Komponen Fungsional) \n\n#### Lifecycle Methods (Komponen Kelas) \n\nKomponen kelas memiliki serangkaian metode _lifecycle_ yang dipanggil pada berbagai tahapan keberadaan komponen (saat dibuat, diperbarui, atau dihapus dari DOM). \n\n* `componentDidMount()`: Dipanggil setelah komponen pertama kali di-_render_ ke DOM. Baik untuk melakukan _fetching_ data. \n* `componentDidUpdate(prevProps, prevState)`: Dipanggil setelah komponen diperbarui. \n* `componentWillUnmount()`: Dipanggil sebelum komponen dilepas dari DOM. Baik untuk membersihkan _event listeners_ atau _timers_. \n\n#### Hooks (Komponen Fungsional) \n\n**Hooks** adalah fungsi yang memungkinkan Anda \"mengaitkan\" ke fitur _state_ dan _lifecycle_ React dari komponen fungsional. Ini adalah perubahan besar yang membuat komponen fungsional jauh lebih kuat. \n\n* **`useState`**: Seperti yang sudah dibahas, untuk mengelola _state_ dalam komponen fungsional. \n* **`useEffect`**: Untuk menjalankan efek samping (seperti _fetching_ data, manipulasi DOM, _subscriptions_) setelah _render_. Ini adalah pengganti `componentDidMount`, `componentDidUpdate`, dan `componentWillUnmount` dalam satu _Hook_. \n\n    ```jsx \n    import React, { useState, useEffect } from 'react'; \n\n    function DataFetcher() { \n        const [data, setData] = useState(null); \n\n        useEffect(() => { \n            // Efek samping: mengambil data \n            fetch('[https://api.example.com/data](https://api.example.com/data)') \n                .then(response => response.json()) \n                .then(data => setData(data)); \n\n            // Fungsi cleanup (seperti componentWillUnmount) \n            return () => { \n                // Cleanup jika diperlukan \n            }; \n        }, []); // Array dependensi kosong berarti efek hanya berjalan sekali (saat mount) \n\n        return ( \n            <div> \n                {data ? <p>Data: {data.message}</p> : <p>Memuat data...</p>} \n            </div> \n        ); \n    } \n\n    export default DataFetcher; \n    ``` \n\n* **`useContext`**: Untuk mengakses konteks React (cara untuk meneruskan data melalui _tree_ komponen tanpa harus meneruskan _props_ secara manual di setiap level). \n* **`useRef`**: Untuk mengakses elemen DOM atau nilai yang _mutable_ tanpa menyebabkan _re-render_. \n* **`useMemo` / `useCallback`**: Untuk optimasi performa dengan melakukan _memoization_. \n\n--- \n\n## Virtual DOM \n\n**Virtual DOM** adalah representasi ringan dari DOM sesungguhnya dalam memori. Ketika _state_ atau _props_ suatu komponen berubah, React akan membuat _Virtual DOM_ baru dan membandingkannya dengan _Virtual DOM_ sebelumnya. Ini disebut _\"diffing\"_. React kemudian hanya memperbarui bagian-bagian DOM sesungguhnya yang benar-benar berubah, daripada memperbarui seluruhnya. Ini adalah alasan utama di balik performa tinggi React. \n\n--- \n\n## Memulai Proyek React \n\nCara termudah untuk memulai proyek React adalah dengan menggunakan **Vite** atau **Create React App**. \n\n### Menggunakan Vite (Direkomendasikan untuk Proyek Baru) \n\nVite adalah _tool_ pembangunan _frontend_ yang sangat cepat. \n\n```bash \nnpm create vite my-react-app -- --template react \ncd my-react-app \nnpm install \nnpm run dev \n``` \n\n### Menggunakan Create React App (Alternatif) \n\n_Create React App_ adalah _toolchain_ resmi untuk proyek React. \n\n```bash \nnpx create-react-app my-react-app \ncd my-react-app \nnpm start \n``` \n\n--- \n\n## Struktur Proyek Umum \n\nProyek React biasanya memiliki struktur seperti ini: \n\n```plain/text \nmy-react-app/ \n├── public/ \n│   └── index.html (File HTML utama) \n├── src/ \n│   ├── index.js (Entry point aplikasi React) \n│   ├── App.js (Komponen utama aplikasi Anda) \n│   ├── components/ (Folder untuk komponen-komponen yang dapat digunakan kembali) \n│   │   ├── Button.js \n│   │   └── Navbar.js \n│   ├── pages/ (Folder untuk komponen halaman/view) \n│   │   ├── HomePage.js \n│   │   └── AboutPage.js \n│   ├── assets/ (Gambar, CSS, dll.) \n│   └── index.css (Global CSS) \n└── package.json (Dependensi proyek dan skrip) \n``` \n\n--- \n\n## Contoh Aplikasi Sederhana: To-Do List \n\nMari kita buat contoh sederhana menggunakan konsep-konsep di atas. \n\n```jsx \nimport React, { useState } from 'react'; \n\nfunction TodoList() { \n    const [todos, setTodos] = useState([]); \n    const [newTodo, setNewTodo] = useState(''); \n\n    const addTodo = () => { \n        if (newTodo.trim() !== '') { \n            setTodos([...todos, { id: Date.now(), text: newTodo, completed: false }]); \n            setNewTodo(''); \n        } \n    }; \n\n    const toggleComplete = (id) => { \n        setTodos(todos.map(todo => \n            todo.id === id ? { ...todo, completed: !todo.completed } : todo \n        )); \n    }; \n\n    const deleteTodo = (id) => { \n        setTodos(todos.filter(todo => todo.id !== id)); \n    }; \n\n    return ( \n        <div> \n            <h1>Daftar Tugas</h1> \n            <input \n                type=\"text\" \n                value={newTodo} \n                onChange={(e) => setNewTodo(e.target.value)} \n                placeholder=\"Tambahkan tugas baru\" \n            /> \n            <button onClick={addTodo}>Tambah</button> \n            <ul> \n                {todos.map(todo => ( \n                    <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}> \n                        {todo.text} \n                        <button onClick={() => toggleComplete(todo.id)}> \n                            {todo.completed ? 'Batal Selesai' : 'Selesai'} \n                        </button> \n                        <button onClick={() => deleteTodo(todo.id)}>Hapus</button> \n                    </li> \n                ))} \n            </ul> \n        </div> \n    ); \n} \n\nexport default TodoList; \n``` \n\nDalam contoh ini: \n\n* Kita menggunakan `useState` untuk mengelola daftar tugas (`todos`) dan nilai input (`newTodo`). \n* Fungsi `addTodo`, `toggleComplete`, dan `deleteTodo` memanipulasi _state_ `todos` secara _immutable_ (membuat array baru daripada mengubah yang sudah ada). \n* Kita menggunakan metode `map` untuk me-_render_ setiap tugas sebagai elemen `<li>`. \n* _Props_ `key` sangat penting saat me-_render_ daftar elemen untuk membantu React mengidentifikasi item yang berubah, ditambahkan, atau dihapus secara efisien. \n\n--- \n\n## Kesimpulan dan Langkah Selanjutnya \n\nAnda sekarang telah memahami fundamental React JS, termasuk konsep komponen, JSX, _props_, _state_, _Virtual DOM_, dan _Hooks_. Ini adalah pondasi yang kuat untuk memulai perjalanan Anda sebagai pengembang React. \n\nUntuk langkah selanjutnya, Anda bisa menjelajahi: \n\n* **React Router:** Untuk mengelola navigasi di aplikasi _multi-page_. \n* **Manajemen State Lanjutan:** Seperti Redux atau Context API untuk aplikasi yang lebih kompleks. \n* **Styling di React:** CSS-in-JS (Styled Components, Emotion), CSS Modules, Tailwind CSS. \n* **Fetching Data:** Menggunakan _library_ seperti Axios atau `react-query`. \n* **Optimasi Performa:** _Memoization_ dengan `useMemo` dan `useCallback`. \n\nTeruslah berlatih dan membangun proyek-proyek kecil untuk memperdalam pemahaman Anda. Selamat belajar React!",
        author: "Adjidev",
        date: new Date(7, ).toLocaleDateString(),
        readTime: "5 Menit Membaca",
        tags: ["React", "Frontend", "JavaScript"],
        thumbnail: "https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        icon: "FaReact"
    },
];